-- Database: m5

-- DROP DATABASE IF EXISTS m5;

-- CREATE DATABASE m5
--     WITH
--     OWNER = postgres
--     ENCODING = 'UTF8'
--     LC_COLLATE = 'English_United States.1252'
--     LC_CTYPE = 'English_United States.1252'
--     LOCALE_PROVIDER = 'libc'
--     TABLESPACE = pg_default
--     CONNECTION LIMIT = -1
--     IS_TEMPLATE = False;

/* Create views to be loaded into PBI */

/* Separate the calendar table and add a column for month name and quarters to calendar_view */
select * from calendar limit 10;
drop view if exists calendar_view cascade;
create view calendar_view ("Date", "Week ID", "Weekday", "Day Number", "Month Number", "Month", "Quarter", "Year") as (
	select date, week_id, weekday, wday, month,
		case
			when month = 1 then 'January'
			when month = 2 then 'February'
			when month = 3 then 'March'
			when month = 4 then 'April'
			when month = 5 then 'May'
			when month = 6 then 'June'		
			when month = 7 then 'July'
			when month = 8 then 'August'
			when month = 9 then 'September'
			when month = 10 then 'October'
			when month = 11 then 'November'
			when month = 12 then 'December'
		end as month_name,
		case
			when month in (1, 2, 3) then 'Q1'
			when month in (4, 5, 6) then 'Q2'
			when month in (7, 8, 9) then 'Q3'
			when month in (10, 11, 12) then 'Q4'
		end as quarter,
		year
	from calendar
	order by date
);
select * from calendar_view;

/* Create view of events calendar */
drop view if exists events_calendar;
create view events_calendar as (
	select date as "Date", event_name_1 as "Event Name", event_type_1 as "Event Type"
	from calendar
	where event_name_1 is not null
	union
	select date, event_name_2, event_type_2
	from calendar
	where event_name_2 is not null
);
select * from events_calendar;

/* Create view of SNAP dates calendar */
drop view if exists snap_calendar;
create view snap_calendar ("Date", "State", "SNAP") as ( 
	select date, 'CA' as "State", "snap_CA"
	from calendar
	union
	select date, 'TX' as "State", "snap_TX"
	from calendar
	union
	select date, 'WI' as "State", "snap_WI"
	from calendar
	order by date
);
select * from snap_calendar;


/* Create sales_view: replace d_i values with their corresponding dates + column of item prices */
drop view if exists sales_intermed_view cascade;
create view sales_intermed_view ("Date", "Week ID", "Item", "Dept", "Category", "Store", "State", "Quantity") as (
	with sales_dates as (
		select date, week_id, item_id, dept_id, cat_id, store_id, state_id, qty
		from sales s
		join (
			select date, week_id, d
			from calendar
		) dd
		on s.day = dd.d
	)
	select sd.*, sc."SNAP"
	from sales_dates sd
	join snap_calendar sc
	on sd.date = sc."Date" and sd.state_id = sc."State"
);
select * from sales_intermed_view limit 100;
select count(*) from sales_intermed_view;

-- create materialized views so I can index them for faster joins

drop materialized view if exists sales_intermed_mv cascade;
create materialized view sales_intermed_mv as (
	select * from sales_intermed_view
);

drop materialized view if exists prices_mv cascade;
create materialized view prices_mv ("Store", "Item", "Week ID", "Unit Price") as (
	select * from prices
);

drop index if exists idx_sales_store_item;
drop index if exists idx_prices_store_item;
create index idx_sales_store_item on sales_intermed_mv("Store", "Item", "Week ID");
create index idx_prices_store_item on prices_mv("Store", "Item", "Week ID");

drop materialized view if exists sales_info_mv cascade;
create materialized view sales_info_mv as (
	select smv.*,
		pmv."Unit Price"
	from sales_intermed_mv smv
	join prices_mv pmv
	on smv."Store" = pmv."Store" and smv."Item" = pmv."Item" and smv."Week ID" = pmv."Week ID"
);
select count (*) from sales_info_mv;

drop view if exists sales_view;
create view sales_view as (
	select * from sales_info_mv
	order by "Date"
);
select * from sales_view limit 1000;
select count(*) from sales_view;

/* View for sales prices */
drop view if exists prices_view;
create view prices_view ("Store", "Item", "Week ID", "Unit Price") as (
	select * from prices
)


/* EDA */
/* How many items in each department? */
with dept_item_list as (
	select "Dept", "Item"
	from sales_view
	group by "Dept", "Item"
)
select "Dept", count("Item")
from dept_item_list
group by "Dept";


/* Revenue generated by each state */
-- select "State",
-- 	sum("Quantity" * "Unit Price") as "Revenue"
-- from sales_info_mv
-- group by "State";

with state_revenues as (
	select "State",
		sum("Quantity" * "Unit Price") as "Revenue"
	from sales_info_mv
	group by "State"
),
total_revenue as (
	select sum("Revenue") as "Total Revenue"
	from state_revenues
)
select state_revenues.*,
	round(state_revenues."Revenue" / total_revenue."Total Revenue" * 100, 2) as "% Total Revenue"
from state_revenues, total_revenue;


/* Revenue generated by each store */
-- select "Store",
-- 	sum("Quantity" * "Unit Price") as "Revenue"
-- from sales_info_mv
-- group by "Store";

with store_revenues as (
	select "Store",
		sum("Quantity" * "Unit Price") as "Revenue"
	from sales_info_mv
	group by "Store"
),
total_revenue as (
	select sum("Revenue") as "Total Revenue"
	from store_revenues
)
select store_revenues.*,
	round(store_revenues."Revenue" / total_revenue."Total Revenue" * 100, 2) as "% Total Revenue"
from store_revenues, total_revenue;


/* QoQ revenue and % change for each store */
select * from sales_info_mv limit 100;
select * from calendar_view;

drop materialized view if exists sales_price_qy_mv;
create materialized view sales_price_qy_mv as (
	select sap_mv.*,
		cv."Quarter", cv."Year"
	from sales_info_mv sap_mv, 
		(select "Date", "Quarter", "Year" from calendar_view) cv
	where sap_mv."Date" = cv."Date"
);

with qy_store_revenue as (
	select "Store", "Quarter", "Year", 
		sum("Quantity" * "Unit Price") as "Revenue"
	from sales_price_qy_mv
	group by "Store", "Year", "Quarter"
),
qoq_store_revenue as (
	select *, 
		lag("Revenue", 1) over (partition by "Store" order by "Year", "Quarter") as "Previous Q Revenue"
		-- "Revenue" over (partition by "Store" order by "Q-Y" rows between 1 preceding and current row) as "Previous Q Revenue"
	from qy_store_revenue
)
-- select * from qoq_store_revenue;
select "Store", "Quarter", "Year", "Revenue", 
	round(("Revenue" - "Previous Q Revenue")/"Previous Q Revenue" * 100, 2) as "QoQ % Change"
from qoq_store_revenue;


